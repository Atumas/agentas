from feature import Feature
from file_selection import FileSelection
from repository import Repository
from files import Files
from generation_tools import generate_branch_name, build_context_string
from termcolor import colored

from gpt_engineer.core.ai import AI
from gpt_engineer.core.prompt import Prompt
from gpt_engineer.core.default.steps import improve_fn, handle_improve_mode
from gpt_engineer.core.default.disk_memory import DiskMemory
from gpt_engineer.core.default.paths import PREPROMPTS_PATH, memory_path
from gpt_engineer.core.preprompts_holder import PrepromptsHolder
from gpt_engineer.core.prompt import Prompt

from prompt_toolkit import prompt as cli_input
from prompt_toolkit.validation import ValidationError, Validator
from prompt_toolkit import PromptSession as InputSession
from prompt_toolkit.completion import WordCompleter


class FeatureValidator(Validator):
    def validate(self, document):
        text = document.text
        if not text:
            raise ValidationError(
                message="Feature description cannot be empty", cursor_position=len(text)
            )


def initialize_new_feature(
    ai: AI, feature: Feature, repository: Repository, no_branch: bool
):
    feature.clear_feature()

    update_feature_description(feature)

    branch_name = generate_branch_name(ai, feature.get_description())

    branch_name = cli_input("\nConfirm branch name: ", default=branch_name)

    if not no_branch:
        repository.create_branch(branch_name)
        print("\nFeature branch created.\n")


def update_user_file_selection(file_selection: FileSelection):
    file_selection.update_yaml_from_tracked_files()
    file_selection.open_yaml_in_editor()
    input(
        "Please edit the file selection for this feature and then press Enter to continue..."
    )


def update_feature_description(feature: Feature):
    feature.open_feature_in_editor()
    input("Please edit the feature file and then press Enter to continue...")


def update_task_description(feature: Feature):
    feature.open_task_in_editor()
    input("Please edit the task file and then press Enter to continue...")


def check_for_unstaged_changes(
    repository: Repository,
):
    git_context = repository.get_git_context()

    if git_context.unstaged_changes:
        if input(
            "Unstaged changes present are you sure you want to proceed? y/n"
        ).lower() not in ["", "y", "yes"]:
            print("Ok, not proceeding.")
            return


def confirm_feature_context_and_task_with_user(
    feature: Feature, file_selection: FileSelection
):
    file_selection.update_yaml_from_tracked_files()
    file_string = file_selection.get_pretty_from_yaml()

    feature_description = feature.get_description()
    task = feature.get_task()

    # list feature, files and task
    print(f"Feature: {feature_description}\n\n")
    print(f"Files: \n\nrepo\n{file_string}\n\n")
    print(f"Task: {task}\n\n")

    #  do you want to attempt this task?
    if cli_input("Do you want to implement this task? y/n: ").lower() in [
        "y",
        "yes",
    ]:
        return True

    return False


def complete_task():
    pass

    # feature.complete task
    # then


def adjust_feature_task_or_files():
    pass
    # todo : create a function which uses the test4.py example code approach to offer a selection of options to the user

    # c - complete the task and start a new one

    # f - "edit feature" using update_feature_description step
    # s - "edit file selection" using update_user_file_selection step
    # t - "edit task" using update_task_description step

    #


def run_task_loop(
    project_path,
    feature: Feature,
    repository: Repository,
    ai: AI,
    file_selection: FileSelection,
):

    memory = DiskMemory(memory_path(project_path))
    preprompts_holder = PrepromptsHolder(PREPROMPTS_PATH)

    context_string = build_context_string(feature, repository.get_git_context())

    prompt = Prompt(feature.get_task(), prefix="Task: ")

    files = Files(project_path, file_selection.get_from_yaml())

    improve_lambda = lambda: improve_fn(
        ai, prompt, files, memory, preprompts_holder, context_string
    )

    print("\n---- begining code generation ----\n")
    updated_files_dictionary = handle_improve_mode(improve_lambda, memory)
    print("\n---- ending code generation ----\n")

    files.write_to_disk(updated_files_dictionary)

    review_changes(project_path, feature, repository, ai, file_selection)


def review_changes(
    project_path,
    feature: Feature,
    repository: Repository,
    ai: AI,
    file_selection: FileSelection,
):

    completer = WordCompleter(["r", "c", "u"], ignore_case=True)
    session = InputSession()

    # Using prompt to get user input
    result = session.prompt(
        """Please review the unstaged changes generated by GPT Engineer.. 

r: Delete and retry the generation (incorporating changes to prompt files)
c: Complete task and stage changes 
u: Undo changes and exit
""",
        completer=completer,
    ).lower()

    if result == "r":
        print("Deleting changes and rerunning generation...")
        repository.undo_unstaged_changes()
        run_task_loop(project_path, feature, repository, ai, file_selection)

    if result == "c":
        print("Completing task... ")
        repository.stage_all_changes()
        feature.complete_task()
        file_selection.update_yaml_from_tracked_files()
        if cli_input("Do you want to start a new task? y/n: ").lower() in [
            "y",
            "yes",
        ]:
            update_task_description(feature)
            run_task_loop(project_path, feature, repository, ai, file_selection)
        return

    if result == "u":
        print("Undo the last operation.")
        repository.undo_unstaged_changes()
        return
